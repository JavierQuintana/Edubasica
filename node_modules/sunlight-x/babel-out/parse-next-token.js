"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseNextToken = parseNextToken;

var _continuation = require("./continuation.js");

var _util = require("./util.js");

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* eslint require-jsdoc: 0, no-magic-numbers: ["error", { "ignore": [-1, 0, 1, 2, 3] }]*/

function isIdentMatch(context) {
  return context.language.identFirstLetter.test(context.reader.current());
}

// token parsing functions
function parseKeyword(context) {
  return util.matchWord(context, context.language.keywords, "keyword");
}

function parseCustomTokens(context) {
  for (var tokenName in context.language.customTokens) {
    var token = util.matchWord(context, context.language.customTokens[tokenName], tokenName);
    if (token !== null) return token;
  }

  return null;
}

function parseOperator(context) {
  return util.matchWord(context, context.language.operators, "operator");
}

function parsePunctuation(context) {
  var current = context.reader.current();
  if (context.language.punctuation.test(util.regexEscape(current))) return context.createToken("punctuation", current, context.reader.getLine(), context.reader.getColumn());

  return null;
}

function parseIdent(context) {
  var line = context.reader.getLine();
  var column = context.reader.getColumn();

  if (!isIdentMatch(context)) return null;

  var ident = context.reader.current();

  for (;;) {
    var peek = context.reader.peek();
    if (peek === context.reader.EOF || !context.language.identAfterFirstLetter.test(peek)) break;

    ident += context.reader.read();
  }

  return context.createToken("ident", ident, line, column);
}

function parseDefault(context) {
  if (context.defaultData.text === "") {
    // new default token
    context.defaultData.line = context.reader.getLine();
    context.defaultData.column = context.reader.getColumn();
  }

  context.defaultData.text += context.reader.current();
  return null;
}

function parseScopes(context) {
  var current = context.reader.current();

  for (var tokenName in context.language.scopes) {
    var specificScopes = context.language.scopes[tokenName];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = specificScopes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var scope = _step.value;

        var opener = scope[0];

        var value = current + context.reader.peek(opener.length - 1);

        if (opener !== value && (!context.language.caseInsensitive || value.toUpperCase() !== opener.toUpperCase())) continue;

        var line = context.reader.getLine();
        var column = context.reader.getColumn();
        context.reader.read(opener.length - 1);
        var continuation = new _continuation.Continuation(scope, tokenName);
        return continuation.process(context, continuation, value, line, column);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return null;
}

function parseNumber(context) {
  return context.language.numberParser(context);
}

function parseCustomRules(context) {
  var customRules = context.language.customParseRules;

  if (customRules === undefined) return null;

  for (var i = 0; i < customRules.length; i++) {
    var token = customRules[i](context);
    if (token) return token;
  }

  return null;
}

function parseNextToken(context) {
  if (context.language.doNotParse.test(context.reader.current())) return parseDefault(context);

  return parseCustomRules(context) || parseCustomTokens(context) || parseKeyword(context) || parseScopes(context) || parseIdent(context) || parseNumber(context) || parseOperator(context) || parsePunctuation(context) || parseDefault(context);
}
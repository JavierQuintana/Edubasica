"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CodeReader = undefined;

var _util = require("./util.js");

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

class CodeReader {

  constructor(text) {
    this.index = 0;
    this.line = 1;
    this.column = 1;
    this.EOF = ""; // TODO: remove
    this.nextReadBeginsLine = false;

    // Normalize line endings to unix
    this.text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");

    this.length = text.length;
    this.currentChar = text.charAt(0);
  }

  toString() {
    return `length: ${this.length}, index: ${this.index}, line: ${this.line}, column: ${this.column}, current: [${this.currentChar}]`;
  }

  current() {
    return this.currentChar;
  }

  currentAndPeek() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

    return this.text.substr(this.index, count);
  }

  peek() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

    return this.text.substr(this.index + 1, count);
  }

  substring() {
    return this.text.substring(this.index);
  }

  peekSubstring() {
    return this.text.substring(this.index + 1);
  }

  currentAndPeekTillEOL() {
    var startIndex = this.index;
    var endIndex = this.text.indexOf("\n", startIndex);
    if (endIndex >= 0) return this.text.substring(startIndex, endIndex);
    return this.text.substring(startIndex);
  }

  read() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

    if (count === 0) return "";

    var value = this.peek(count);

    if (value !== this.EOF) {
      // advance index
      this.index += value.length;
      this.column += value.length;

      // update line count. TODO: algorithm incorrect.
      if (this.nextReadBeginsLine) {
        this.line++;
        this.column = 1;
        this.nextReadBeginsLine = false;
      }

      var newlineCount = value.substring(0, value.length - 1).replace(/[^\n]/g, "").length;
      if (newlineCount > 0) {
        this.line += newlineCount;
        this.column = 1;
      }

      var lastChar = util.lastChar(value);
      if (lastChar === "\n") this.nextReadBeginsLine = true;

      this.currentChar = lastChar;
    } else {
      this.index = this.length;
      this.currentChar = this.EOF;
    }

    return value;
  }

  text() {
    return this.text;
  }

  getLine() {
    return this.line;
  }

  getColumn() {
    return this.column;
  }

  isEOF() {
    return this.index >= this.length;
  }

  isPeekEOF() {
    return this.index + 1 >= this.length;
  }

  isStartOfLine() {
    return this.column === 1;
  }

  // Check if the current character is preceded by whitespace or nothing.
  isPrecededByWhitespaceOnly() {
    var lineBeforeCurrent = this.text.substring(this.index - this.column + 1, this.index);
    return (/^\s*$/.test(lineBeforeCurrent)
    );
  }

  isEol() {
    return this.nextReadBeginsLine;
  }

  EOF() {
    return this.EOF;
  }

  match(str) {
    return this.text.substr(this.index, str.length) === str;
  }

  matchPeek(str) {
    return this.text.substr(this.index + 1, str.length) === str;
  }
}
exports.CodeReader = CodeReader;
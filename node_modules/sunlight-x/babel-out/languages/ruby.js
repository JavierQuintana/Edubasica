"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.contextItems = exports.operators = exports.namedIdentRules = exports.identAfterFirstLetter = exports.identFirstLetter = exports.scopes = exports.customParseRules = exports.customTokens = exports.keywords = exports.name = undefined;

var _logger = require("../logger.js");

var logger = _interopRequireWildcard(_logger);

var _util = require("../util.js");

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// sunlight-x: Intelligent Syntax Highlighting, Modernized
// Copyright 2017 Leung Wing-chung. All rights reserved.
// Use of this source code is governed by a Apache License Version 2.0, that can
// be found in the LICENSE file.

/* eslint no-magic-numbers: 1 */
var name = exports.name = "ruby";

// http://www.ruby-doc.org/docs/keywords/1.9/
var keywords = exports.keywords = ["BEGIN", "END", "__ENCODING__", "__END__", "__FILE__", "__LINE__", "alias", "and", "begin", "break", "case", "class", "def", "defined?", "do", "else", "elsif", "end", "ensure", "false", "for", "if", "in", "module", "next", "nil", "not", "or", "redo", "rescue", "retry", "return", "self", "super", "then", "true", "undef", "unless", "until", "when", "while", "yield"];

var customTokens = exports.customTokens = {
  // http://www.ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/function.html
  function: {
    values: ["Array", "Float", "Integer", "String", "at_exit", "autoload", "binding", "caller", "catch", "chop!", "chop", "chomp!", "chomp", "eval", "exec", "exit!", "exit", "fail", "fork", "format", "gets", "global_variables", "gsub!", "gsub", "iterator?", "lambda", "load", "local_variables", "loop", "open", "p", "print", "printf", "proc", "putc", "puts", "raise", "rand", "readline", "readlines", "require", "select", "sleep", "split", "sprintf", "srand", "sub!", "sub", "syscall", "system", "test", "trace_var", "trap", "untrace_var"],
    boundary: "\\W"
  },

  specialOperator: {
    values: ["defined?", "eql?", "equal?"],
    boundary: "\\W"
  }
};

var customParseRules = exports.customParseRules = [
// regex literal, mostly the same as javascript
function (context) {
  if (context.reader.current() !== "/") return null;

  var previousNonWsToken = context.token(context.count() - 1);
  var previousToken = null;
  if (context.defaultData.text !== "") previousToken = context.createToken("default", context.defaultData.text, context.defaultData.line, context.defaultData.column);

  if (!previousToken) previousToken = previousNonWsToken;

  if (
  // The first token of the string
  previousToken !== undefined && (
  // Since Ruby doesn't require statement terminators, if the previous token
  // was whitespace and contained a newline, then we're good.
  previousToken.name !== "default" || previousToken.value.indexOf("\n") < 0)) {
    // In these case the / stands for division.
    if (util.contains(["keyword", "ident", "number"], previousNonWsToken.name)) return null;
    if (previousNonWsToken.name === "punctuation" && !util.contains(["(", "{", "[", ","], previousNonWsToken.value)) return null;
  }

  var line = context.reader.getLine();
  var column = context.reader.getColumn();

  // read the regex literal
  var regexLiteral = "/";
  var charClass = false;
  while (!context.reader.isPeekEOF()) {
    var next = context.reader.read();
    regexLiteral += next;

    if (next === "\\") regexLiteral += context.reader.read();else if (next === "[") charClass = true;else if (next === "]") charClass = false;else if (next === "/" && !charClass) break;
  }

  // Read the regex modifiers. For the sake of simplicity we accept all
  // characters, but currently only "ioxmusen" are supported.
  while (!context.reader.isPeekEOF() && /[A-Za-z]/.test(context.reader.peek())) {
    regexLiteral += context.reader.read();
  }return context.createToken("regexLiteral", regexLiteral, line, column);
},

// symbols
function (context) {
  // this is goofy, because it needs to recognize things like "foo = true ? :true :not_true"
  // and detect that :not_true is not a symbol
  if (context.reader.current() !== ":" || !/[a-zA-Z_]/.test(context.reader.peek())) return null;

  // basically look backward until a line break not preceded by an operator or
  // a comma
  var walker = context.getTokenWalker();
  var parenCount = 0;
  var count = walker.index - 1;
  while (walker.hasPrev()) {
    var _token = walker.prev();
    if (_token.name === "operator") {
      if (parenCount === 0) if (_token.value === "?" && walker.index < count) {
        // this is a ternary operator, not a symbol
        return null;
      } else if (_token.value === ":") {
        break;
      }
    } else if (_token.name === "punctuation") {
      switch (_token.value) {
        case "(":
          parenCount--;
          break;
        case ")":
          parenCount++;
          break;
      }
    } else if (_token.name === "default" && /\n/.test(_token.value)) {
      if (walker.hasPrev()) {
        var prevToken = walker.peek(-1);
        if (prevToken.name === "operator" || prevToken.name === "punctuation" && prevToken.value === ",")
          // line continuation
          continue;
      }
      break;
    }
  }

  // read the symbol
  var symbol = /^:\w+/.exec(context.reader.substring())[0];
  var token = context.createToken("symbol", symbol, context.reader.getLine(), context.reader.getColumn());
  context.reader.read(symbol.length - 1); // already read the ":"
  return token;
},

// heredoc declaration
// heredocs can be stacked and delimited, so this is a bit complicated
// we keep track of the heredoc declarations in context.items.heredocQueue,
// and then use them later in the heredoc custom parse rule below
function (context) {
  if (context.reader.current() !== "<" || !/<[\w'"`-]/.test(context.reader.peek(2))) return null;

  var line = context.reader.getLine();
  var column = context.reader.getColumn();

  // cannot be preceded by an a number or a string
  var walker = context.getTokenWalker();
  if (walker.hasPrev()) {
    var prevToken = walker.prev();
    if (util.contains(["number", "string"], prevToken.name)) return null;
  }

  // there are still cases where heredocs are falsely detected, because it would require performing
  // static analysis

  // e.g. foo <<a
  // if foo is an object that has the "<<" method defined, then it will perform a left shift
  // if foo is a function that takes a string argument, it will interpret it as a heredoc

  // so, we just force you to have whitespace between << and the rhs operand in these ambiguous cases

  // can be between quotes (double, single or back) or not, or preceded by a hyphen
  context.reader.read(2);

  var value = "<<";
  var ident = "";
  var current = context.reader.current();
  if (current === "-") {
    value += current;
    ident += current;
    current = context.reader.read();
  }

  var delimiter = "";
  if (util.contains(['"', "'", "`"], current)) delimiter = current;else ident += current;

  value += current;

  while (!context.reader.isPeekEOF()) {
    var peek = context.reader.peek();
    if (peek === "\n" || delimiter === "" && /\W/.test(peek)) break;

    if (peek === "\\") {
      var peek2 = context.reader.peek(2);
      if (delimiter !== "" && util.contains(["\\" + delimiter, "\\\\"], peek2)) {
        value += peek2;
        ident += context.reader.read(2);
        continue;
      }
    }

    value += context.reader.read();

    if (delimiter !== "" && peek === delimiter) break;

    ident += peek;
  }

  if (Array.isArray(context.items.heredocQueue)) context.items.heredocQueue.push(ident);else logger.errorInvalidValue(`context.items.heredocQueue is not an array.`, context.items.heredocQueue);

  return context.createToken("heredocDeclaration", value, line, column);
},

// heredoc
function (context) {
  if (!Array.isArray(context.items.heredocQueue)) {
    logger.errorInvalidValue(`context.items.heredocQueue is not an array.`, context.items.heredocQueue);
    return null;
  }

  if (context.items.heredocQueue.length === 0) return null;

  // there must have been at least one line break since the heredoc
  // declaration(s)
  if (context.defaultData.text.replace(/[^\n]/g, "").length === 0) return null;

  // we're confirmed to be in the heredoc body, so read until all of the
  // heredoc declarations have been satisfied
  var tokens = [];
  var value = context.reader.current();
  var ignoreWhitespace = false;
  while (Array.isArray(context.items.heredocQueue) && context.items.heredocQueue.length > 0 && !context.reader.isPeekEOF()) {
    var declaration = context.items.heredocQueue.shift();
    if (!(typeof declaration === "string")) {
      logger.errorInvalidValue(`Content of context.items.heredocQueue is not a string.`, declaration);
      return null;
    }

    if (declaration.charAt(0) === "-") {
      declaration = declaration.substring(1);
      ignoreWhitespace = true;
    }

    var line = context.reader.getLine();
    var column = context.reader.getColumn();

    // read until "\n{declaration}\n"
    // unless the declaration is prefixed with "-", then we don't care about
    // preceding whitespace, but it must be on its own line e.g. \n[
    // \t]*{declaration}\n
    var regex = new RegExp("\\n" + (ignoreWhitespace ? "[ \\t]*" : "") + util.regexEscape(declaration) + "\\n");
    var substring = context.reader.peekSubstring();
    var match = regex.exec(substring);
    // If no match, the whole file should be consumed.
    var lengthOfMatch = match ? match.index + match[0].length : substring.length;
    value += context.reader.read(lengthOfMatch);

    tokens.push(context.createToken("heredoc", value, line, column));
    value = "";
  }

  // Reset queue. This is needed if the reader reach EOF.
  context.items.heredocQueue = [];

  return tokens.length > 0 ? tokens : null;
},

// raw string/regex
// http://www.ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/syntax.html#string
// http://www.ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/syntax.html#regexp
function (context) {
  // begin with % or %q or %Q with a non-alphanumeric delimiter (opening bracket/paren are closed by corresponding closing bracket/paren)
  if (context.reader.current() !== "%") return null;

  var line = context.reader.getLine();
  var column = context.reader.getColumn();

  var readCount = 1;
  var isRegex = false;
  var peek = context.reader.peek();
  if (peek === "q" || peek === "Q" || peek === "r") {
    readCount++;
    if (peek === "r") isRegex = true;
  } else if (/[A-Za-z0-9=]$/.test(peek)) {
    // % or %= operator (how does ruby differentiate between "%=" and
    // "%=string="?)
    return null;
  }

  var value = "%";

  value += context.reader.read(readCount);
  var delimiter = value.charAt(value.length - 1);
  switch (delimiter) {
    case "(":
      delimiter = ")";
      break;
    case "[":
      delimiter = "]";
      break;
    case "{":
      delimiter = "}";
      break;
  }

  // read until the delimiter
  while (!context.reader.isPeekEOF()) {
    var next = context.reader.read();
    // Escapes.
    if (next === "\\") {
      value += next + context.reader.read();
      continue;
    }
    value += next;
    if (next === delimiter) break;
  }

  if (isRegex)
    // read potential regex modifiers
    while (!context.reader.isPeekEOF()) {
      if (!/[A-Za-z]/.test(context.reader.peek())) break;

      value += context.reader.read();
    }

  return context.createToken(isRegex ? "regexLiteral" : "rawString", value, line, column);
},

// doc comments
// http://www.ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/syntax.html#embed_doc
function (context) {
  var line = context.reader.getLine();
  var column = context.reader.getColumn();

  var value = "=begin";

  // these begin on with a line that starts with "=begin" and end with a line that starts with "=end"
  // apparently stuff on the same line as "=end" is also part of the comment
  if (!context.reader.isStartOfLine() || !context.reader.match(value)) return null;

  context.reader.read(value.length - 1);

  var endOfDoc = "\n=end";
  while (!context.reader.isPeekEOF() && !context.reader.matchPeek(endOfDoc)) {
    value += context.reader.read();
  }value += context.reader.read(endOfDoc.length);

  while (!context.reader.isPeekEOF() && context.reader.peek() !== "\n") {
    value += context.reader.read();
  }return context.createToken("docComment", value, line, column);
}];

var scopes = exports.scopes = {
  string: [['"', '"', util.escapeSequences.concat(['\\"']), false], ["'", "'", ["\\'", "\\\\"], false]],
  comment: [["#", "\n", [], true]],
  subshellCommand: [["`", "`", ["\\`"], false]],
  globalVariable: [["$", { length: 1, regex: /[\W]/ }, [], true]],
  instanceVariable: [["@", { length: 1, regex: /[\W]/ }, [], true]]
};

var identFirstLetter = exports.identFirstLetter = /[A-Za-z_]/;
var identAfterFirstLetter = exports.identAfterFirstLetter = /\w/;

var namedIdentRules = exports.namedIdentRules = {
  follows: [
  // class names
  // function names
  [{ token: "keyword", values: ["class", "def"] }, util.whitespace],

  // extended classes
  [{ token: "keyword", values: ["class"] }, util.whitespace, { token: "ident" }, util.whitespace, { token: "operator", values: ["<", "<<"] }, util.whitespace]],

  precedes: [
  // static variable access
  [util.whitespace, { token: "operator", values: ["::"] }],

  // new-ing a class
  [util.whitespace, { token: "operator", values: ["."] }, util.whitespace, { token: "ident", values: ["new"] }, util.whitespace, { token: "punctuation", values: ["("] }]]
};

var operators = exports.operators = ["?", "...", "..", ".", "::", ":", "[]", "+=", "+", "-=", "-", "**=", "*=", "**", "*", "/=", "/", "%=", "%", "&&=", "&=", "&&", "&", "||=", "|=", "||", "|", "^=", "^", "~", "\\", // line continuation
"<=>", "<<=", "<<", "<=", "<", ">>=", ">>", ">=", ">", "!~", "!=", "!", "=>", "===", "==", "=~", "="];

var contextItems = exports.contextItems = {
  heredocQueue: []
};
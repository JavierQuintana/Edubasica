"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.operators = exports.namedIdentRules = exports.identAfterFirstLetter = exports.identFirstLetter = exports.scopes = exports.customTokens = exports.customParseRules = exports.keywords = exports.name = undefined;

var _util = require("../util.js");

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var name = exports.name = "erlang";

// http://www.haskell.org/haskellwiki/Keywords
// sunlight-x: Intelligent Syntax Highlighting, Modernized
// Copyright 2017 Leung Wing-chung. All rights reserved.
// Use of this source code is governed by a Apache License Version 2.0, that can
// be found in the LICENSE file.

var keywords = exports.keywords = ["after", "andalso", "and", "band", "begin", "bnot", "bor", "bsl", "bsr", "bxor", "case", "catch", "cond", "div", "end", "fun", "if", "let", "not", "of", "orelse", "or", "query", "receive", "rem", "try", "when", "xor", "true", "false"];

var customParseRules = exports.customParseRules = [
// atom/function/userDefinedFunction detection
function (context) {
  var line = context.reader.getLine();
  var column = context.reader.getColumn();

  if (!/[A-Za-z_]/.test(context.reader.current())) return null;

  var peek = void 0;
  var count = 0;
  // read the ident (they can have letters, numbers, underscores and @-signs in them)
  while ((peek = context.reader.peek(++count)) && peek.length === count) {
    if (!/[\w@]$/.test(peek)) break;
  }var ident = context.reader.currentAndPeek(peek.length);

  // if the next non-whitespace character is "(", then it's a function
  count--;
  var isFunction = false;
  while ((peek = context.reader.peek(++count)) && peek.length === count) {
    if (!/\s$/.test(peek)) {
      if (/\($/.test(peek)) isFunction = true;

      break;
    }
  } // a little inefficient because reading the ident will have to happen again,
  // but it might be a keyword or something
  if (!isFunction && !/^[A-Z_]/.test(ident)) return null;

  context.reader.read(ident.length - 1);
  count = 1;

  if (!isFunction) return context.createToken("ident", ident, line, column);

  var parenCount = 1; // Already read a "(" before.
  // is it a function declaration? (preceded by -> operator)
  while ((peek = context.reader.peek(++count)) && peek.length === count) {
    var letter = peek.charAt(peek.length - 1);

    if (parenCount === 0) {
      // the next thing is a bunch of whitespace followed by ->, or fail
      while ((peek = context.reader.peek(++count)) && peek.length === count) {
        if (!/\s$/.test(peek)) {
          if (/->$/.test(context.reader.peek(count + 1))) {
            // function declaration
            context.userDefinedNameStore.addName(ident, name);

            return context.createToken("userDefinedFunction", ident, line, column);
          }

          break;
        }
      }break;
    }

    if (letter === "(") parenCount++;else if (letter === ")") parenCount--;
  }

  // just a regular function call
  return context.createToken("function", ident, line, column);
}];

var customTokens = exports.customTokens = {
  moduleAttribute: {
    values: ["-module", "-export", "-import", "-compile", "-vsn", "-behaviour", "-record", "-include", "-define", "-file", "-type", "-spec", "on_load"],
    boundary: "\\b"
  },

  macroDirective: {
    values: ["-undef", "-ifdef", "-ifndef", "-else", "-endif"],
    boundary: "\\b"
  }
};

var scopes = exports.scopes = {
  string: [['"', '"', util.escapeSequences.concat(['\\"']), false]],
  quotedAtom: [["'", "'", ["\\'", "\\\\"], false]],
  comment: [["%", "\n", [], true]],
  char: [["$", { regex: /[^\w\\]/, length: 1 }, [], true]],
  macro: [["?", { regex: /[^\w?]/, length: 1 }, [], true]]
};

var identFirstLetter = exports.identFirstLetter = /[A-Za-z_]/;
var identAfterFirstLetter = exports.identAfterFirstLetter = /[\w@]/;

var namedIdentRules = exports.namedIdentRules = {
  custom: [function (context) {
    return context.userDefinedNameStore.hasName(context.tokens[context.index].value, name);
  }],

  precedes: [[{ token: "operator", values: [":"] }]]
};

var operators = exports.operators = ["<-", "<", "||", "=:=", "=/=", "==", "=<", "=", "*", "<<", ",", ">=", ">>", ">", ":", "#", "!", "++", "+", "->", "--", "-", "/=", "/"];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.caseInsensitive = exports.customParseRules = exports.customTokens = exports.identAfterFirstLetter = exports.identFirstLetter = exports.operators = exports.scopes = exports.keywords = exports.name = undefined;
exports.numberParser = numberParser;

var _util = require("../util.js");

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var name = exports.name = "6502asm"; // sunlight-x: Intelligent Syntax Highlighting, Modernized
// Copyright 2017 Leung Wing-chung. All rights reserved.
// Use of this source code is governed by a Apache License Version 2.0, that can
// be found in the LICENSE file.

var keywords = exports.keywords = [
// conditional branch ops
"BCC", "BCS", "BEQ", "BMI", "BNE", "BPL", "BVC", "BVS",
// comparison ops
"CMP", "CPX", "CPY",
// flag ops
"CLC", "CLD", "CLI", "CLV", "SEC", "SED", "SEI",
// register ops
"DEX", "DEY", "INX", "INY", "TAX", "TAY", "TXA", "TYA",
// regular ops
"BRK", "NOP", "RTI", "RTS", "ASL", "LSR", "ROL", "ROR", "ADC", "AND", "BIT", "DEC", "EOR", "INC", "JMP", "JSR", "LDA", "LDX", "LDY", "ORA", "SBC", "STA", "STX", "STY",
// stack ops
"PHA", "PHP", "PLA", "PLP", "TSX", "TXS"];

var scopes = exports.scopes = {
  string: [['"', '"', [], false]],
  comment: [[";", "\n", [], true]]
};

var operators = exports.operators = [">>", "<<", ">=", "<=", "==", "!=", "&&", "||", "~", "-", "<", ">", "*", "/", "%", "+", "-", "=", "&", "^", "|", "?"];

var identFirstLetter = exports.identFirstLetter = /[A-Za-z]/; // must be alpha
var identAfterFirstLetter = exports.identAfterFirstLetter = /\w/; // alphanumeric and underscore

var customTokens = exports.customTokens = {
  illegalOpcode: {
    values: [
    // illegal ops
    "SLO", "RLA", "SRE", "RRA", "SAX", "LAX", "DCP", "ISC", "ANC", "ALR", "ARR", "XAA", "AXS", "AHX", "SHY", "SHX", "TAS", "LAS"],
    boundary: "\\b"
  },

  pseudoOp: {
    values: [
    // pre-processor pseudo-ops (not a complete list!)
    "BYTE", "WORD", "DS", "ORG", "RORG", "ALIGN", "MAC", "ENDM", "SUBROUTINE"],
    boundary: "\\b"
  }
};

var customParseRules = exports.customParseRules = [function (context) {
  var current = context.reader.current();
  if (current !== "#") return null;

  var line = context.reader.getLine();
  var column = context.reader.getColumn();

  // Quick and dirty: everything between "#" (inclusive) and whitespace
  // (exclusive) is a constant too dirty.  Need to account for parens and
  // square brackets, whitespace can appear inside them. New routine: once
  // inside () or [], anything goes, but once outside, terminate with
  // whitespace
  var parenCount = 0;
  var bracketCount = 0;
  var peek = context.reader.peek();
  var value = current;
  while (parenCount > 0 || bracketCount > 0 || !/\s/.test(peek)) {
    if (peek === ")" && parenCount > 0) parenCount--;

    if (peek === "]" && bracketCount > 0) bracketCount--;

    if (peek === "(") parenCount++;

    if (peek === "[") bracketCount++;

    value += context.reader.read();
    peek = context.reader.peek();
  }

  return context.createToken("constant", value, line, column);
},

// labels
function () {
  var validLabelOps = ["BCC", "BCS", "BEQ", "BMI", "BNE", "BPL", "BVC", "BVS", "JMP", "JSR"];

  return function (context) {
    var label = void 0,
        peek = void 0;
    var line = context.reader.getLine();
    var column = context.reader.getColumn();

    if (!/[A-Za-z]/.test(context.reader.current())) return null;

    var prevToken = util.getPreviousNonWsToken(context.getAllTokens(), context.count());

    // Check if it is just a regular ident.
    if ((!prevToken || prevToken.name !== "keyword" || !util.contains(validLabelOps, prevToken.value, true)) && context.count() > 0 && !/\n$/.test(context.defaultData.text)) return null;

    // Read until the end of the ident.
    label = context.reader.current();
    while ((peek = context.reader.peek()) !== context.reader.EOF) {
      if (!/\w/.test(peek)) break;

      label += context.reader.read();
    }

    return context.createToken("label", label, line, column);
  };
}()];

var caseInsensitive = exports.caseInsensitive = true;

/**
 * Number parser of 6502asm.
 * TODO: parsing appears to be incorrect. But needs specs before fixing.
 * @param {ParserContext} context
 * @returns {Token?}
 */
function numberParser(context) {
  var current = context.reader.current();
  var line = context.reader.getLine();
  var column = context.reader.getColumn();

  var number = void 0;
  // is first char a digit?
  if (!/\d/.test(current)) {
    // does it start with "$" (hex) or "%" (binary)?
    if (current !== "$" && current !== "%") return null;

    // hex/binary number
    number = current + context.reader.read();
  } else {
    number = current;
    // is it a decimal?
    if (context.reader.peek() === ".") number += context.reader.read();
  }

  // easy way out: read until it's not a number or letter a-f
  // this will work for hex ($FF), octal (012), decimal and binary
  while (!context.reader.isPeekEOF()) {
    if (!/[A-Fa-f0-9]/.test(context.reader.peek())) break;

    number += context.reader.read();
  }

  return context.createToken("number", number, line, column);
}